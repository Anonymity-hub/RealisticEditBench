diff --git a/xarray/indexes/range_index.py b/xarray/indexes/range_index.py
--- a/xarray/indexes/range_index.py
+++ b/xarray/indexes/range_index.py
@@ -20,8 +20,9 @@ class RangeCoordinateTransform(CoordinateTransform):
 
     start: float
     stop: float
+    _step: float | None
 
-    __slots__ = ("start", "stop")
+    __slots__ = ("_step", "start", "stop")
 
     def __init__(
         self,
@@ -39,6 +40,7 @@ def __init__(
 
         self.start = start
         self.stop = stop
+        self._step = None  # Will be calculated by property
 
     @property
     def coord_name(self) -> Hashable:
@@ -54,7 +56,13 @@ def size(self) -> int:
 
     @property
     def step(self) -> float:
-        return (self.stop - self.start) / self.size
+        if self._step is not None:
+            return self._step
+        if self.size > 0:
+            return (self.stop - self.start) / self.size
+        else:
+            # For empty arrays, default to 1.0
+            return 1.0
 
     def forward(self, dim_positions: dict[str, Any]) -> dict[Hashable, Any]:
         positions = dim_positions[self.dim]
@@ -81,12 +89,22 @@ def equals(
     def slice(self, sl: slice) -> "RangeCoordinateTransform":
         new_range = range(self.size)[sl]
         new_size = len(new_range)
+
         new_start = self.start + new_range.start * self.step
         new_stop = self.start + new_range.stop * self.step
 
-        return type(self)(
-            new_start, new_stop, new_size, self.coord_name, self.dim, dtype=self.dtype
+        result = type(self)(
+            new_start,
+            new_stop,
+            new_size,
+            self.coord_name,
+            self.dim,
+            dtype=self.dtype,
         )
+        if new_size == 0:
+            # For empty slices, preserve step from parent
+            result._step = self.step
+        return result
 
 
 class RangeIndex(CoordinateTransformIndex):