diff --git a/sympy/core/expr.py b/sympy/core/expr.py
--- a/sympy/core/expr.py
+++ b/sympy/core/expr.py
@@ -17,7 +17,7 @@
 from .kind import NumberKind
 from sympy.utilities.exceptions import sympy_deprecation_warning
 from sympy.utilities.misc import as_int, func_name, filldedent
-from sympy.utilities.iterables import has_variety, sift, _sift_true_false
+from sympy.utilities.iterables import has_variety, _sift_true_false
 from mpmath.libmp import mpf_log, prec_to_dps
 from mpmath.libmp.libintmath import giant_steps
 
@@ -1775,36 +1775,45 @@ def as_coefficient(self, expr: Expr) -> Expr | None:
         else:
             return None
 
-    def as_independent(self, *deps, **hint) -> tuple[Expr, Expr]:
+    def as_independent(
+        self,
+        *deps: Basic | type[Basic],
+        as_Add: bool | None = None,
+        strict: bool = True,
+    ) -> tuple[Expr, Expr]:
         """
         A mostly naive separation of a Mul or Add into arguments that are not
         are dependent on deps. To obtain as complete a separation of variables
         as possible, use a separation method first, e.g.:
 
-        * separatevars() to change Mul, Add and Pow (including exp) into Mul
-        * .expand(mul=True) to change Add or Mul into Add
-        * .expand(log=True) to change log expr into an Add
+        * ``separatevars()`` to change Mul, Add and Pow (including exp) into Mul
+        * ``.expand(mul=True)`` to change Add or Mul into Add
+        * ``.expand(log=True)`` to change log expr into an Add
 
         The only non-naive thing that is done here is to respect noncommutative
-        ordering of variables and to always return (0, 0) for `self` of zero
-        regardless of hints.
+        ordering of variables and to always return ``(0, 0)`` for ``self`` of
+        zero regardless of hints.
 
-        For nonzero `self`, the returned tuple (i, d) has the
-        following interpretation:
+        For nonzero ``self``, the returned tuple ``(i, d)`` has the following
+        interpretation:
 
-        * i will has no variable that appears in deps
-        * d will either have terms that contain variables that are in deps, or
-          be equal to 0 (when self is an Add) or 1 (when self is a Mul)
-        * if self is an Add then self = i + d
-        * if self is a Mul then self = i*d
-        * otherwise (self, S.One) or (S.One, self) is returned.
+        * ``i`` has no variable that appears in deps
+        * ``d`` will either have terms that contain variables that are in deps,
+          or be equal to ``0`` (when ``self`` is an ``Add``) or ``1`` (when
+          ``self`` is a ``Mul``)
+        * if ``self`` is an Add then ``self = i + d``
+        * if ``self`` is a Mul then ``self = i*d``
+        * otherwise ``(self, S.One)`` or ``(S.One, self)`` is returned.
 
-        To force the expression to be treated as an Add, use the hint as_Add=True
+        To force the expression to be treated as an Add, use the argument
+        ``as_Add=True``.
+
+        The ``strict`` argument is deprecated and has no effect.
 
         Examples
         ========
 
-        -- self is an Add
+        -- ``self`` is an Add
 
         >>> from sympy import sin, cos, exp
         >>> from sympy.abc import x, y, z
@@ -1818,12 +1827,13 @@ def as_independent(self, *deps, **hint) -> tuple[Expr, Expr]:
         >>> (2*x*sin(x) + y + x + z).as_independent(x, y)
         (z, 2*x*sin(x) + x + y)
 
-        -- self is a Mul
+        -- ``self`` is a Mul
 
         >>> (x*sin(x)*cos(y)).as_independent(x)
         (cos(y), x*sin(x))
 
-        non-commutative terms cannot always be separated out when self is a Mul
+        Non-commutative terms cannot always be separated out when ``self`` is a
+        Mul
 
         >>> from sympy import symbols
         >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)
@@ -1838,7 +1848,7 @@ def as_independent(self, *deps, **hint) -> tuple[Expr, Expr]:
         >>> ((x-n1)*(x-y)).as_independent(x)
         (1, (x - y)*(x - n1))
 
-        -- self is anything else:
+        -- ``self`` is anything else:
 
         >>> (sin(x)).as_independent(x)
         (1, sin(x))
@@ -1847,12 +1857,12 @@ def as_independent(self, *deps, **hint) -> tuple[Expr, Expr]:
         >>> exp(x+y).as_independent(x)
         (1, exp(x + y))
 
-        -- force self to be treated as an Add:
+        -- force ``self`` to be treated as an Add:
 
         >>> (3*x).as_independent(x, as_Add=True)
         (0, 3*x)
 
-        -- force self to be treated as a Mul:
+        -- force ``self`` to be treated as a Mul:
 
         >>> (3+x).as_independent(x, as_Add=False)
         (1, x + 3)
@@ -1865,9 +1875,9 @@ def as_independent(self, *deps, **hint) -> tuple[Expr, Expr]:
         >>> (y*(-3+x)).as_independent(x)
         (y, x - 3)
 
-        -- use .as_independent() for true independence testing instead
-           of .has(). The former considers only symbols in the free
-           symbols while the latter considers all symbols
+        -- use ``.as_independent()`` for true independence testing instead of
+           ``.has()``. The former considers only symbols in the free symbols
+           while the latter considers all symbols
 
         >>> from sympy import Integral
         >>> I = Integral(x, (x, 1, 2))
@@ -1880,10 +1890,10 @@ def as_independent(self, *deps, **hint) -> tuple[Expr, Expr]:
         >>> (I + x).as_independent(x) == (I, x)
         True
 
-        Note: when trying to get independent terms, a separation method
-        might need to be used first. In this case, it is important to keep
-        track of what you send to this routine so you know how to interpret
-        the returned values
+        Note: when trying to get independent terms, a separation method might
+        need to be used first. In this case, it is important to keep track of
+        what you send to this routine so you know how to interpret the returned
+        values
 
         >>> from sympy import separatevars, log
         >>> separatevars(exp(x+y)).as_independent(x)
@@ -1916,55 +1926,47 @@ def as_independent(self, *deps, **hint) -> tuple[Expr, Expr]:
         if self is S.Zero:
             return (self, self)
 
-        func = self.func
-        want: type[Add] | type[Mul]
-        if hint.get('as_Add', isinstance(self, Add) ):
-            want = Add
+        if as_Add is None:
+            as_Add = self.is_Add
+
+        syms, other = _sift_true_false(deps, lambda d: isinstance(d, Symbol))
+        syms_set = set(syms)
+
+        if other:
+            def has(e):
+                return e.has_xfree(syms_set) or e.has(*other)
         else:
-            want = Mul
-
-        # sift out deps into symbolic and other and ignore
-        # all symbols but those that are in the free symbols
-        sym = set()
-        other = []
-        for d in deps:
-            if isinstance(d, Symbol):  # Symbol.is_Symbol is True
-                sym.add(d)
-            else:
-                other.append(d)
-
-        def has(e):
-            """return the standard has() if there are no literal symbols, else
-            check to see that symbol-deps are in the free symbols."""
-            has_other = e.has(*other)
-            if not sym:
-                return has_other
-            return has_other or e.has(*(e.free_symbols & sym))
-
-        if (want is not func or
-                func is not Add and func is not Mul):
-            if has(self):
-                return (want.identity, self)
-            else:
-                return (self, want.identity)
+            def has(e):
+                return e.has_xfree(syms_set)
+
+        if as_Add:
+            if not self.is_Add:
+                if has(self):
+                    return (S.Zero, self)
+                else:
+                    return (self, S.Zero)
+
+            depend, indep = _sift_true_false(self.args, has)
+            return (self.func(*indep), _unevaluated_Add(*depend))
+
         else:
-            if func is Add:
-                args = list(self.args)
-            else:
-                args, nc = self.args_cnc()
-
-        d = sift(args, has)
-        depend = d[True]
-        indep = d[False]
-        if func is Add:  # all terms were treated as commutative
-            return (Add(*indep), _unevaluated_Add(*depend))
-        else:  # handle noncommutative by stopping at first dependent term
+            if not self.is_Mul:
+                if has(self):
+                    return (S.One, self)
+                else:
+                    return (self, S.One)
+
+            args, nc = self.args_cnc()
+            depend, indep = _sift_true_false(args, has)
+
+            # handle noncommutative by stopping at first dependent term
             for i, n in enumerate(nc):
                 if has(n):
                     depend.extend(nc[i:])
                     break
                 indep.append(n)
-            return Mul(*indep), _unevaluated_Mul(*depend)
+
+            return self.func(*indep), _unevaluated_Mul(*depend)
 
     def as_real_imag(self, deep=True, **hints) -> tuple[Expr, Expr]:
         """Performs complex expansion on 'self' and returns a tuple