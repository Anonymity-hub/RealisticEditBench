diff --git a/sphinx/ext/autodoc/_documenters.py b/sphinx/ext/autodoc/_documenters.py
--- a/sphinx/ext/autodoc/_documenters.py
+++ b/sphinx/ext/autodoc/_documenters.py
@@ -1624,7 +1624,7 @@
         canonical_fullname = self.get_canonical_fullname()
         if (
             not self.props.doc_as_attr
-            and not isinstance(self.object, NewType)
+            and not isinstance(self.props._obj, NewType)
             and canonical_fullname
             and self.props.full_name != canonical_fullname
         ):
@@ -1632,20 +1632,22 @@
 
         # add inheritance info, if wanted
         if not self.props.doc_as_attr and self.options.show_inheritance:
-            if inspect.getorigbases(self.object):
+            if inspect.getorigbases(self.props._obj):
                 # A subclass of generic types
                 # refs: PEP-560 <https://peps.python.org/pep-0560/>
-                bases = list(self.object.__orig_bases__)
-            elif hasattr(self.object, '__bases__') and len(self.object.__bases__):
+                bases = list(self.props._obj.__orig_bases__)
+            elif hasattr(self.props._obj, '__bases__') and len(
+                self.props._obj.__bases__
+            ):
                 # A normal class
-                bases = list(self.object.__bases__)
+                bases = list(self.props._obj.__bases__)
             else:
                 bases = []
 
             self._events.emit(
                 'autodoc-process-bases',
                 self.props.full_name,
-                self.object,
+                self.props._obj,
                 self.options,
                 bases,
             )
@@ -1659,7 +1661,7 @@
 
     def get_object_members(self, want_all: bool) -> tuple[bool, list[ObjectMember]]:
         members = get_class_members(
-            self.object,
+            self.props._obj,
             self.props.parts,
             self.get_attr,
             self.config.autodoc_inherit_docstrings,
@@ -1680,11 +1682,11 @@
         elif self.options.inherited_members:
             return False, list(members.values())
         else:
-            return False, [m for m in members.values() if m.class_ == self.object]
+            return False, [m for m in members.values() if m.class_ == self.props._obj]
 
     def get_doc(self) -> list[list[str]] | None:
-        if isinstance(self.object, TypeVar):
-            if self.object.__doc__ == TypeVar.__doc__:
+        if isinstance(self.props._obj, TypeVar):
+            if self.props._obj.__doc__ == TypeVar.__doc__:
                 return []
         if self.props.doc_as_attr:
             # Don't show the docstring of the class when it is an alias.
@@ -1703,19 +1705,19 @@
             classdoc_from = self.config.autoclass_content
 
         docstrings = []
-        attrdocstring = getdoc(self.object, self.get_attr)
+        attrdocstring = getdoc(self.props._obj, self.get_attr)
         if attrdocstring:
             docstrings.append(attrdocstring)
 
         # for classes, what the "docstring" is can be controlled via a
         # config value; the default is only the class docstring
         if classdoc_from in {'both', 'init'}:
-            __init__ = self.get_attr(self.object, '__init__', None)
+            __init__ = self.get_attr(self.props._obj, '__init__', None)
             initdocstring = getdoc(
                 __init__,
                 self.get_attr,
                 self.config.autodoc_inherit_docstrings,
-                self.object,
+                self.props._obj,
                 '__init__',
             )
             # for new-style classes, no __init__ means default __init__
@@ -1726,12 +1728,12 @@
                 initdocstring = None
             if not initdocstring:
                 # try __new__
-                __new__ = self.get_attr(self.object, '__new__', None)
+                __new__ = self.get_attr(self.props._obj, '__new__', None)
                 initdocstring = getdoc(
                     __new__,
                     self.get_attr,
                     self.config.autodoc_inherit_docstrings,
-                    self.object,
+                    self.props._obj,
                     '__new__',
                 )
                 # for new-style classes, no __new__ means default __new__
@@ -1767,22 +1769,22 @@
         mode = _get_render_mode(self.config.autodoc_typehints_format)
         short_literals = self.config.python_display_short_literal_types
 
-        if isinstance(self.object, NewType):
-            supertype = restify(self.object.__supertype__, mode=mode)
+        if isinstance(self.props._obj, NewType):
+            supertype = restify(self.props._obj.__supertype__, mode=mode)
 
             more_content = StringList([_('alias of %s') % supertype, ''], source='')
-        if isinstance(self.object, TypeVar):
-            attrs = [repr(self.object.__name__)]
+        if isinstance(self.props._obj, TypeVar):
+            attrs = [repr(self.props._obj.__name__)]
             attrs.extend(
                 stringify_annotation(constraint, mode, short_literals=short_literals)
-                for constraint in self.object.__constraints__
+                for constraint in self.props._obj.__constraints__
             )
-            if self.object.__bound__:
-                bound = restify(self.object.__bound__, mode=mode)
+            if self.props._obj.__bound__:
+                bound = restify(self.props._obj.__bound__, mode=mode)
                 attrs.append(r'bound=\ ' + bound)
-            if self.object.__covariant__:
+            if self.props._obj.__covariant__:
                 attrs.append('covariant=True')
-            if self.object.__contravariant__:
+            if self.props._obj.__contravariant__:
                 attrs.append('contravariant=True')
 
             more_content = StringList(
@@ -1800,7 +1802,7 @@
 
         if self.props.doc_as_attr and not self.get_variable_comment():
             try:
-                alias = restify(self.object, mode=mode)
+                alias = restify(self.props._obj, mode=mode)
                 more_content = StringList([_('alias of %s') % alias], source='')
             except AttributeError:
                 pass  # Invalid class object is passed.
@@ -1894,7 +1896,7 @@
             pass
 
     def should_suppress_value_header(self) -> bool:
-        if self.object is UNINITIALIZED_ATTR:
+        if self.props._obj is UNINITIALIZED_ATTR:
             return True
         else:
             doc = self.get_doc() or []
@@ -1909,7 +1911,9 @@
     def add_directive_header(self, sig: str) -> None:
         super().add_directive_header(sig)
         sourcename = self.get_sourcename()
-        if self.options.annotation is SUPPRESS or inspect.isgenericalias(self.object):
+        if self.options.annotation is SUPPRESS or inspect.isgenericalias(
+            self.props._obj
+        ):
             pass
         elif self.options.annotation:
             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)
@@ -1936,11 +1940,11 @@
                 if (
                     self.options.no_value
                     or self.should_suppress_value_header()
-                    or ismock(self.object)
+                    or ismock(self.props._obj)
                 ):
                     pass
                 else:
-                    objrepr = object_description(self.object)
+                    objrepr = object_description(self.props._obj)
                     self.add_line('   :value: ' + objrepr, sourcename)
             except ValueError:
                 pass
@@ -1978,7 +1982,7 @@
 
         _add_content_generic_alias_(
             more_content,
-            self.object,
+            self.props._obj,
             autodoc_typehints_format=self.config.autodoc_typehints_format,
         )
         super().add_content(more_content)
@@ -2011,7 +2015,7 @@
             kwargs.setdefault('short_literals', True)
 
         try:
-            if self.object == object.__init__ and self.parent != object:  # NoQA: E721
+            if self.props._obj == object.__init__ and self.parent != object:  # NoQA: E721
                 # Classes not having own __init__() method are shown as no arguments.
                 #
                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).
@@ -2019,22 +2023,22 @@
                 args = '()'
             else:
                 if inspect.isstaticmethod(
-                    self.object, cls=self.parent, name=self.props.object_name
+                    self.props._obj, cls=self.parent, name=self.props.object_name
                 ):
                     self._events.emit(
-                        'autodoc-before-process-signature', self.object, False
+                        'autodoc-before-process-signature', self.props._obj, False
                     )
                     sig = inspect.signature(
-                        self.object,
+                        self.props._obj,
                         bound_method=False,
                         type_aliases=self.config.autodoc_type_aliases,
                     )
                 else:
                     self._events.emit(
-                        'autodoc-before-process-signature', self.object, True
+                        'autodoc-before-process-signature', self.props._obj, True
                     )
                     sig = inspect.signature(
-                        self.object,
+                        self.props._obj,
                         bound_method=True,
                         type_aliases=self.config.autodoc_type_aliases,
                     )
@@ -2055,7 +2059,7 @@
         super().add_directive_header(sig)
 
         sourcename = self.get_sourcename()
-        obj = self.parent.__dict__.get(self.props.object_name, self.object)
+        obj = self.parent.__dict__.get(self.props.object_name, self.props._obj)
         if inspect.isabstractmethod(obj):
             self.add_line('   :abstractmethod:', sourcename)
         if inspect.iscoroutinefunction(obj) or inspect.isasyncgenfunction(obj):
@@ -2117,25 +2121,24 @@
                             properties=frozenset(),
                         )
                         documenter.parent = self.parent
-                        documenter.object = dispatchmeth
                         sigs.append(documenter.format_signature())
         if overloaded and self.analyzer is not None:
             if inspect.isstaticmethod(
-                self.object, cls=self.parent, name=self.props.object_name
+                self.props._obj, cls=self.parent, name=self.props.object_name
             ):
                 actual = inspect.signature(
-                    self.object,
+                    self.props._obj,
                     bound_method=False,
                     type_aliases=self.config.autodoc_type_aliases,
                 )
             else:
                 actual = inspect.signature(
-                    self.object,
+                    self.props._obj,
                     bound_method=True,
                     type_aliases=self.config.autodoc_type_aliases,
                 )
 
-            __globals__ = safe_getattr(self.object, '__globals__', {})
+            __globals__ = safe_getattr(self.props._obj, '__globals__', {})
             for overload in self.analyzer.overloads[self.props.dotted_parts]:
                 overload = self.merge_default_value(actual, overload)
                 overload = evaluate_signature(
@@ -2143,7 +2146,7 @@
                 )
 
                 if not inspect.isstaticmethod(
-                    self.object, cls=self.parent, name=self.props.object_name
+                    self.props._obj, cls=self.parent, name=self.props.object_name
                 ):
                     parameters = list(overload.parameters.values())
                     overload = overload.replace(parameters=parameters[1:])
@@ -2203,7 +2206,7 @@
             return self._new_docstrings
         if self.props.name == '__init__':
             docstring = getdoc(
-                self.object,
+                self.props._obj,
                 self.get_attr,
                 self.config.autodoc_inherit_docstrings,
                 self.parent,
@@ -2221,7 +2224,7 @@
                 return []
         elif self.props.name == '__new__':
             docstring = getdoc(
-                self.object,
+                self.props._obj,
                 self.get_attr,
                 self.config.autodoc_inherit_docstrings,
                 self.parent,
@@ -2303,16 +2306,16 @@
 
     @property
     def _is_non_data_descriptor(self) -> bool:
-        return not inspect.isattributedescriptor(self.object)
+        return not inspect.isattributedescriptor(self.props._obj)
 
     def should_suppress_value_header(self) -> bool:
-        if self.object is SLOTS_ATTR:
+        if self.props._obj is SLOTS_ATTR:
             return True
-        if self.object is RUNTIME_INSTANCE_ATTRIBUTE:
+        if self.props._obj is RUNTIME_INSTANCE_ATTRIBUTE:
             return True
-        if self.object is UNINITIALIZED_ATTR:
+        if self.props._obj is UNINITIALIZED_ATTR:
             return True
-        if not self._is_non_data_descriptor or inspect.isgenericalias(self.object):
+        if not self._is_non_data_descriptor or inspect.isgenericalias(self.props._obj):
             return True
         else:
             doc = self.get_doc()
@@ -2328,7 +2331,9 @@
     def add_directive_header(self, sig: str) -> None:
         super().add_directive_header(sig)
         sourcename = self.get_sourcename()
-        if self.options.annotation is SUPPRESS or inspect.isgenericalias(self.object):
+        if self.options.annotation is SUPPRESS or inspect.isgenericalias(
+            self.props._obj
+        ):
             pass
         elif self.options.annotation:
             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)
@@ -2355,11 +2360,11 @@
                 if (
                     self.options.no_value
                     or self.should_suppress_value_header()
-                    or ismock(self.object)
+                    or ismock(self.props._obj)
                 ):
                     pass
                 else:
-                    objrepr = object_description(self.object)
+                    objrepr = object_description(self.props._obj)
                     self.add_line('   :value: ' + objrepr, sourcename)
             except ValueError:
                 pass
@@ -2384,7 +2389,7 @@
             orig = self.config.autodoc_inherit_docstrings
             self.config.autodoc_inherit_docstrings = False
 
-            if self.object is SLOTS_ATTR:
+            if self.props._obj is SLOTS_ATTR:
                 # support for __slots__
                 try:
                     parent___slots__ = inspect.getslots(self.parent)
@@ -2404,14 +2409,14 @@
                     return []
 
             if (
-                self.object is RUNTIME_INSTANCE_ATTRIBUTE
+                self.props._obj is RUNTIME_INSTANCE_ATTRIBUTE
                 and _is_runtime_instance_attribute_not_commented(
                     parent=self.parent, obj_path=self.props.parts
                 )
             ):
                 return None
 
-            if self.object is UNINITIALIZED_ATTR:
+            if self.props._obj is UNINITIALIZED_ATTR:
                 return None
 
             if self._is_non_data_descriptor:
@@ -2432,7 +2437,7 @@
             more_content = StringList()
         _add_content_generic_alias_(
             more_content,
-            self.object,
+            self.props._obj,
             autodoc_typehints_format=self.config.autodoc_typehints_format,
         )
         super().add_content(more_content)
@@ -2460,7 +2465,10 @@
             if inspect.isproperty(member):
                 return True
             else:
-                __dict__ = safe_getattr(parent.object, '__dict__', {})
+                # See FakeDirective &c in autosummary, parent might not be a
+                # 'proper' Documenter.
+                obj = parent.props._obj if hasattr(parent, 'props') else None
+                __dict__ = safe_getattr(obj, '__dict__', {})
                 obj = __dict__.get(membername)
                 return isinstance(obj, classmethod) and inspect.isproperty(obj.__func__)
         else:
@@ -2482,7 +2490,7 @@
     def add_directive_header(self, sig: str) -> None:
         super().add_directive_header(sig)
         sourcename = self.get_sourcename()
-        if inspect.isabstractmethod(self.object):
+        if inspect.isabstractmethod(self.props._obj):
             self.add_line('   :abstractmethod:', sourcename)
         # Support for class properties. Note: these only work on Python 3.9.
         if self.props.is_classmethod:
@@ -2511,10 +2519,10 @@
             pass
 
     def _get_property_getter(self) -> Callable[..., Any] | None:
-        if safe_getattr(self.object, 'fget', None):  # property
-            return self.object.fget
-        if safe_getattr(self.object, 'func', None):  # cached_property
-            return self.object.func
+        if safe_getattr(self.props._obj, 'fget', None):  # property
+            return self.props._obj.fget
+        if safe_getattr(self.props._obj, 'func', None):  # cached_property
+            return self.props._obj.func
         return None
 
 
