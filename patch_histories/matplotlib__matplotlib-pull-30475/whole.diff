diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py
--- a/lib/matplotlib/axes/_axes.py
+++ b/lib/matplotlib/axes/_axes.py
@@ -1183,7 +1183,7 @@ def hlines(self, y, xmin, xmax, colors=None, linestyles='solid',
             if self.name == "rectilinear":
                 datalim = lines.get_datalim(self.transData)
                 t = lines.get_transform()
-                updatex, updatey = t.contains_branch_seperately(self.transData)
+                updatex, updatey = t.contains_branch_separately(self.transData)
                 minx = np.nanmin(datalim.xmin)
                 maxx = np.nanmax(datalim.xmax)
                 miny = np.nanmin(datalim.ymin)
@@ -1275,7 +1275,7 @@ def vlines(self, x, ymin, ymax, colors=None, linestyles='solid',
             if self.name == "rectilinear":
                 datalim = lines.get_datalim(self.transData)
                 t = lines.get_transform()
-                updatex, updatey = t.contains_branch_seperately(self.transData)
+                updatex, updatey = t.contains_branch_separately(self.transData)
                 minx = np.nanmin(datalim.xmin)
                 maxx = np.nanmax(datalim.xmax)
                 miny = np.nanmin(datalim.ymin)
@@ -6809,7 +6809,7 @@ def _update_pcolor_lims(self, collection, coords):
                 hasattr(t, '_as_mpl_transform')):
             t = t._as_mpl_transform(self.axes)
 
-        if t and any(t.contains_branch_seperately(self.transData)):
+        if t and any(t.contains_branch_separately(self.transData)):
             trans_to_data = t - self.transData
             coords = trans_to_data.transform(coords)
 
diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py
--- a/lib/matplotlib/axes/_base.py
+++ b/lib/matplotlib/axes/_base.py
@@ -2380,9 +2380,9 @@ def add_collection(self, collection, autolim=True):
             # only update the dataLim for x/y if the collection uses transData
             # in this direction.
             x_is_data, y_is_data = (collection.get_transform()
-                                    .contains_branch_seperately(self.transData))
+                                    .contains_branch_separately(self.transData))
             ox_is_data, oy_is_data = (collection.get_offset_transform()
-                                      .contains_branch_seperately(self.transData))
+                                      .contains_branch_separately(self.transData))
             self.update_datalim(
                 points,
                 updatex=x_is_data or ox_is_data,
@@ -2451,7 +2451,7 @@ def _update_line_limits(self, line):
 
         if line_trf == self.transData:
             data_path = path
-        elif any(line_trf.contains_branch_seperately(self.transData)):
+        elif any(line_trf.contains_branch_separately(self.transData)):
             # Compute the transform from line coordinates to data coordinates.
             trf_to_data = line_trf - self.transData
             # If transData is affine we can use the cached non-affine component
@@ -2474,7 +2474,7 @@ def _update_line_limits(self, line):
         if not data_path.vertices.size:
             return
 
-        updatex, updatey = line_trf.contains_branch_seperately(self.transData)
+        updatex, updatey = line_trf.contains_branch_separately(self.transData)
         if self.name != "rectilinear":
             # This block is mostly intended to handle axvline in polar plots,
             # for which updatey would otherwise be True.
@@ -2527,7 +2527,7 @@ def _update_patch_limits(self, patch):
             vertices = np.vstack(vertices)
 
         patch_trf = patch.get_transform()
-        updatex, updatey = patch_trf.contains_branch_seperately(self.transData)
+        updatex, updatey = patch_trf.contains_branch_separately(self.transData)
         if not (updatex or updatey):
             return
         if self.name != "rectilinear":
diff --git a/lib/matplotlib/collections.py b/lib/matplotlib/collections.py
--- a/lib/matplotlib/collections.py
+++ b/lib/matplotlib/collections.py
@@ -283,7 +283,7 @@ def get_datalim(self, transData):
 
         offsets = self.get_offsets()
 
-        if any(transform.contains_branch_seperately(transData)):
+        if any(transform.contains_branch_separately(transData)):
             # collections that are just in data units (like quiver)
             # can properly have the axes limits set by their shape +
             # offset.  LineCollections that have no offsets can
diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py
--- a/lib/matplotlib/contour.py
+++ b/lib/matplotlib/contour.py
@@ -1333,7 +1333,7 @@ def _process_args(self, *args, corner_mask=None, algorithm=None, **kwargs):
             # if the transform is not trans data, and some part of it
             # contains transData, transform the xs and ys to data coordinates
             if (t != self.axes.transData and
-                    any(t.contains_branch_seperately(self.axes.transData))):
+                    any(t.contains_branch_separately(self.axes.transData))):
                 trans_to_data = t - self.axes.transData
                 pts = np.vstack([x.flat, y.flat]).T
                 transformed_pts = trans_to_data.transform(pts)
diff --git a/lib/matplotlib/transforms.py b/lib/matplotlib/transforms.py
--- a/lib/matplotlib/transforms.py
+++ b/lib/matplotlib/transforms.py
@@ -1418,24 +1418,29 @@ def contains_branch(self, other):
                 return True
         return False
 
-    def contains_branch_seperately(self, other_transform):
+    def contains_branch_separately(self, other_transform):
         """
         Return whether the given branch is a sub-tree of this transform on
         each separate dimension.
 
         A common use for this method is to identify if a transform is a blended
         transform containing an Axes' data transform. e.g.::
 
-            x_isdata, y_isdata = trans.contains_branch_seperately(ax.transData)
+            x_isdata, y_isdata = trans.contains_branch_separately(ax.transData)
 
         """
         if self.output_dims != 2:
-            raise ValueError('contains_branch_seperately only supports '
+            raise ValueError('contains_branch_separately only supports '
                              'transforms with 2 output dimensions')
         # for a non-blended transform each separate dimension is the same, so
         # just return the appropriate shape.
         return (self.contains_branch(other_transform), ) * 2
 
+    # Permanent alias for backwards compatibility (historical typo)
+    def contains_branch_seperately(self, other_transform):
+        """:meta private:"""
+        return self.contains_branch_separately(other_transform)
+
     def __sub__(self, other):
         """
         Compose *self* with the inverse of *other*, cancelling identical terms
@@ -2185,7 +2190,7 @@ def __eq__(self, other):
         else:
             return NotImplemented
 
-    def contains_branch_seperately(self, transform):
+    def contains_branch_separately(self, transform):
         return (self._x.contains_branch(transform),
                 self._y.contains_branch(transform))
 
@@ -2411,14 +2416,14 @@ def _iter_break_from_left_to_right(self):
         for left, right in self._b._iter_break_from_left_to_right():
             yield self._a + left, right
 
-    def contains_branch_seperately(self, other_transform):
+    def contains_branch_separately(self, other_transform):
         # docstring inherited
         if self.output_dims != 2:
-            raise ValueError('contains_branch_seperately only supports '
+            raise ValueError('contains_branch_separately only supports '
                              'transforms with 2 output dimensions')
         if self == other_transform:
             return (True, True)
-        return self._b.contains_branch_seperately(other_transform)
+        return self._b.contains_branch_separately(other_transform)
 
     depth = property(lambda self: self._a.depth + self._b.depth)
     is_affine = property(lambda self: self._a.is_affine and self._b.is_affine)