diff --git a/lib/matplotlib/transforms.py b/lib/matplotlib/transforms.py
--- a/lib/matplotlib/transforms.py
+++ b/lib/matplotlib/transforms.py
@@ -1418,24 +1418,29 @@ def contains_branch(self, other):
                 return True
         return False
 
-    def contains_branch_seperately(self, other_transform):
+    def contains_branch_separately(self, other_transform):
         """
         Return whether the given branch is a sub-tree of this transform on
         each separate dimension.
 
         A common use for this method is to identify if a transform is a blended
         transform containing an Axes' data transform. e.g.::
 
-            x_isdata, y_isdata = trans.contains_branch_seperately(ax.transData)
+            x_isdata, y_isdata = trans.contains_branch_separately(ax.transData)
 
         """
         if self.output_dims != 2:
-            raise ValueError('contains_branch_seperately only supports '
+            raise ValueError('contains_branch_separately only supports '
                              'transforms with 2 output dimensions')
         # for a non-blended transform each separate dimension is the same, so
         # just return the appropriate shape.
         return (self.contains_branch(other_transform), ) * 2
 
+    # Permanent alias for backwards compatibility (historical typo)
+    def contains_branch_seperately(self, other_transform):
+        """:meta private:"""
+        return self.contains_branch_separately(other_transform)
+
     def __sub__(self, other):
         """
         Compose *self* with the inverse of *other*, cancelling identical terms
@@ -2185,7 +2190,7 @@ def __eq__(self, other):
         else:
             return NotImplemented
 
-    def contains_branch_seperately(self, transform):
+    def contains_branch_separately(self, transform):
         return (self._x.contains_branch(transform),
                 self._y.contains_branch(transform))
 
@@ -2411,14 +2416,14 @@ def _iter_break_from_left_to_right(self):
         for left, right in self._b._iter_break_from_left_to_right():
             yield self._a + left, right
 
-    def contains_branch_seperately(self, other_transform):
+    def contains_branch_separately(self, other_transform):
         # docstring inherited
         if self.output_dims != 2:
-            raise ValueError('contains_branch_seperately only supports '
+            raise ValueError('contains_branch_separately only supports '
                              'transforms with 2 output dimensions')
         if self == other_transform:
             return (True, True)
-        return self._b.contains_branch_seperately(other_transform)
+        return self._b.contains_branch_separately(other_transform)
 
     depth = property(lambda self: self._a.depth + self._b.depth)
     is_affine = property(lambda self: self._a.is_affine and self._b.is_affine)