diff --git a/sympy/integrals/manualintegrate.py b/sympy/integrals/manualintegrate.py
--- a/sympy/integrals/manualintegrate.py
+++ b/sympy/integrals/manualintegrate.py
@@ -32,16 +32,14 @@
 from sympy.core.cache import cacheit
 from sympy.core.containers import Dict
 from sympy.core.expr import Expr
-from sympy.core.function import Derivative, expand
+from sympy.core.function import Derivative
 from sympy.core.logic import fuzzy_not
 from sympy.core.mul import Mul
 from sympy.core.numbers import Integer, Number, E
 from sympy.core.power import Pow
 from sympy.core.relational import Eq, Ne
 from sympy.core.singleton import S
 from sympy.core.symbol import Dummy, Symbol, Wild
-from sympy.core.exprtools import factor_terms
-from sympy.core.traversal import preorder_traversal
 from sympy.functions.elementary.complexes import Abs
 from sympy.functions.elementary.exponential import exp, log
 from sympy.functions.elementary.hyperbolic import (HyperbolicFunction, csch,
@@ -66,7 +64,6 @@
 from sympy.simplify.radsimp import fraction
 from sympy.simplify.simplify import simplify
 from sympy.simplify.powsimp import powsimp
-from sympy.simplify.trigsimp import trigsimp, exptrigsimp
 from sympy.solvers.solvers import solve
 from sympy.strategies.core import switch, do_one, null_safe, condition
 from sympy.utilities.iterables import iterable
@@ -1294,7 +1291,7 @@ def pull_out_u_rl(integrand: Expr) -> tuple[Expr, Expr] | None:
 
             # Can integrate a polynomial times OrthogonalPolynomial
             if rule == pull_out_algebraic:
-                if dv.is_Derivative or dv.has(TrigonometricFunction) or \
+                if dv.is_Derivative or dv.has(TrigonometricFunction, HyperbolicFunction) or \
                         isinstance(dv, OrthogonalPolynomial):
                     v_step = integral_steps(dv, symbol)
                     if v_step.contains_dont_know():
@@ -1432,7 +1429,7 @@ def trig_cmplx_exp_rule(integral: IntegralInfo):
     Strategy that rewrites sin, cos, sinh, and cosh in terms of complex exponentials.
     Useful for integration techniques that handle exponentials better.
     Applies only when the integrand belongs to a class that benefits from exponential rewriting,
-    such as combinations involving Error functions.
+    such as combinations involving Gaussian exponentials.
 
     sin(x)  -> (exp(i*x) - exp(-i*x)) / (2*i)
     cos(x)  -> (exp(i*x) + exp(-i*x)) / 2
@@ -1441,15 +1438,14 @@ def trig_cmplx_exp_rule(integral: IntegralInfo):
     """
     integrand, symbol = integral
 
-    if not integrand.has(erf, erfc, erfi, exp):
+    if not integrand.has(exp) and not integrand.has(sin, cos, sinh, cosh):
         return
 
-    if integrand.has(exp):
-        a = Wild('a', exclude=[symbol, 0])
-        b = Wild('b', exclude=[symbol])
-        pattern = exp(a * symbol**2 + b * symbol)
-        if not any(term.match(pattern) for term in integrand.atoms(exp)):
-            return
+    a = Wild('a', exclude=[symbol, 0])
+    b = Wild('b', exclude=[symbol])
+    pattern = exp(a * symbol**2 + b * symbol)
+    if not any(term.match(pattern) for term in integrand.atoms(exp)):
+        return
 
     # Replace trig and hyperbolic functions with their exponential forms
     rewritten = integrand.rewrite([sin, cos, sinh, cosh], exp)
@@ -2038,23 +2034,6 @@ def rewrites_rule(integral):
 def fallback_rule(integral):
     return DontKnowRule(*integral)
 
-def has_cmplx_exp_pair(expr):
-    """
-    Check if the expression contains a pair of complex exponentials
-    that can be simplified to a sin or cos function.
-    """
-    exp_args = set()
-
-    for sub in preorder_traversal(expr):
-        if sub.func == exp:
-            arg = trigsimp(powsimp(factor_terms(expand(sub.args[0]))))
-            exp_args.add(arg)
-
-    for a in exp_args:
-        if -a in exp_args:
-            return True
-    return False
-
 
 # Cache is used to break cyclic integrals.
 # Need to use the same dummy variable in cached expressions for them to match.
@@ -2242,10 +2221,6 @@ def manualintegrate(f, var):
     sympy.integrals.integrals.Integral
     """
     result = integral_steps(f, var).eval()
-    if has_cmplx_exp_pair(result):
-        if result.has(erf):
-            result = result.rewrite(exp, cos).expand().rewrite([sinh, cosh], exp).collect(result.atoms(erf)).collect(result.atoms(exp), factor_terms)
-            result = exptrigsimp(result)
     # Clear the cache of u-parts
     _parts_u_cache.clear()
     # If we got Piecewise with two parts, put generic first