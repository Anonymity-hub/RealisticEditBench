diff --git a/astropy/modeling/core.py b/astropy/modeling/core.py
--- a/astropy/modeling/core.py
+++ b/astropy/modeling/core.py
@@ -28,7 +28,6 @@
 from astropy.nddata.utils import add_array, extract_array
 from astropy.table import Table
 from astropy.units import Quantity, UnitsError, dimensionless_unscaled
-from astropy.units.utils import quantity_asanyarray
 from astropy.utils import (
     find_current_module,
     isiterable,
@@ -47,6 +46,7 @@
     combine_labels,
     get_inputs_and_params,
     make_binary_operator_eval,
+    quantity_asanyarray,
 )
 
 __all__ = [
diff --git a/astropy/modeling/utils.py b/astropy/modeling/utils.py
--- a/astropy/modeling/utils.py
+++ b/astropy/modeling/utils.py
@@ -4,16 +4,28 @@
 This module provides utility functions for the models package.
 """
 
+from __future__ import annotations
+
 import warnings
 
 # pylint: disable=invalid-name
 from collections import UserDict
 from inspect import signature
+from typing import TYPE_CHECKING, overload
 
 import numpy as np
 
 from astropy import units as u
 
+if TYPE_CHECKING:
+    from collections.abc import Sequence
+    from typing import TypeVar
+
+    from numpy.typing import NDArray
+
+    DType = TypeVar("DType", bound=np.generic)
+
+
 __all__ = ["ellipse_extent", "poly_map_domain"]
 
 
@@ -314,3 +326,24 @@ def add(self, operator_name, operator):
         self._set_value(key, operator)
 
         return key
+
+
+@overload
+def quantity_asanyarray(a: Sequence[int]) -> NDArray[np.integer]: ...
+@overload
+def quantity_asanyarray(a: Sequence[int], dtype: DType) -> NDArray[DType]: ...
+@overload
+def quantity_asanyarray(a: Sequence[u.Quantity]) -> u.Quantity: ...
+def quantity_asanyarray(
+    a: Sequence[int] | Sequence[u.Quantity], dtype: DType | None = None
+) -> NDArray[np.integer] | NDArray[DType] | u.Quantity:
+    if (
+        not isinstance(a, np.ndarray)
+        and not np.isscalar(a)
+        and any(isinstance(x, u.Quantity) for x in a)
+    ):
+        return u.Quantity(a, dtype=dtype)
+    else:
+        # skip over some dtype deprecation.
+        dtype = np.float64 if dtype is np.inexact else dtype
+        return np.asanyarray(a, dtype=dtype)
diff --git a/astropy/units/utils.py b/astropy/units/utils.py
--- a/astropy/units/utils.py
+++ b/astropy/units/utils.py
@@ -11,26 +11,20 @@
 import io
 import re
 from fractions import Fraction
-from typing import TYPE_CHECKING, overload
+from typing import TYPE_CHECKING
 
 import numpy as np
 from numpy import finfo
 
 from .errors import UnitScaleError
 
 if TYPE_CHECKING:
-    from collections.abc import Generator, Mapping, Sequence
-    from typing import Literal, SupportsFloat, TypeVar
-
-    from numpy.typing import NDArray
+    from collections.abc import Generator, Mapping
+    from typing import Literal
 
     from .core import NamedUnit
-    from .quantity import Quantity
     from .typing import UnitPower, UnitPowerLike, UnitScale, UnitScaleLike
 
-    DType = TypeVar("DType", bound=np.generic)
-    FloatLike = TypeVar("FloatLike", bound=SupportsFloat)
-
 
 _float_finfo = finfo(float)
 # take float here to ensure comparison with another float is fast
@@ -322,26 +316,3 @@ def resolve_fractions(
     elif not a_is_fraction and b_is_fraction:
         a = maybe_simple_fraction(a)
     return a, b
-
-
-@overload
-def quantity_asanyarray(a: Sequence[int]) -> NDArray[np.integer]: ...
-@overload
-def quantity_asanyarray(a: Sequence[int], dtype: DType) -> NDArray[DType]: ...
-@overload
-def quantity_asanyarray(a: Sequence[Quantity]) -> Quantity: ...
-def quantity_asanyarray(
-    a: Sequence[int] | Sequence[Quantity], dtype: DType | None = None
-) -> NDArray[np.integer] | NDArray[DType] | Quantity:
-    from .quantity import Quantity
-
-    if (
-        not isinstance(a, np.ndarray)
-        and not np.isscalar(a)
-        and any(isinstance(x, Quantity) for x in a)
-    ):
-        return Quantity(a, dtype=dtype)
-    else:
-        # skip over some dtype deprecation.
-        dtype = np.float64 if dtype is np.inexact else dtype
-        return np.asanyarray(a, dtype=dtype)