diff --git a/astropy/io/fits/convenience.py b/astropy/io/fits/convenience.py
--- a/astropy/io/fits/convenience.py
+++ b/astropy/io/fits/convenience.py
@@ -453,10 +453,10 @@ def writeto(
 
     Notes
     -----
-    gzip, zip and bzip2 compression algorithms are natively supported.
+    gzip, zip, bzip2 and lzma compression algorithms are natively supported.
     Compression mode is determined from the filename extension
-    ('.gz', '.zip' or '.bz2' respectively).  It is also possible to pass a
-    compressed file object, e.g. `gzip.GzipFile`.
+    ('.gz', '.zip', '.bz2' or '.xz' respectively).  It is also possible to pass
+    a compressed file object, e.g. `gzip.GzipFile`.
     """
     hdu = _makehdu(data, header)
     if hdu.is_image and not isinstance(hdu, PrimaryHDU):
diff --git a/astropy/io/fits/file.py b/astropy/io/fits/file.py
--- a/astropy/io/fits/file.py
+++ b/astropy/io/fits/file.py
@@ -17,7 +17,7 @@
 import numpy as np
 
 # NOTE: Python can be built without bz2.
-from astropy.utils.compat.optional_deps import HAS_BZ2
+from astropy.utils.compat.optional_deps import HAS_BZ2, HAS_LZMA
 from astropy.utils.data import (
     _is_url,
     _requires_fsspec,
@@ -44,6 +44,8 @@
 if HAS_BZ2:
     import bz2
 
+if HAS_LZMA:
+    import lzma
 
 # Maps astropy.io.fits-specific file mode names to the appropriate file
 # modes to use for the underlying raw files.
@@ -98,6 +100,7 @@
 GZIP_MAGIC = b"\x1f\x8b\x08"
 PKZIP_MAGIC = b"\x50\x4b\x03\x04"
 BZIP2_MAGIC = b"\x42\x5a"
+LZMA_MAGIC = b"\xfd7zXZ\x00"
 
 
 def _is_bz2file(fileobj):
@@ -107,6 +110,13 @@ def _is_bz2file(fileobj):
         return False
 
 
+def _is_lzmafile(fileobj):
+    if HAS_LZMA:
+        return isinstance(fileobj, lzma.LZMAFile)
+    else:
+        return False
+
+
 def _normalize_fits_mode(mode):
     if mode is not None and mode not in IO_FITS_MODES:
         if TEXT_RE.match(mode):
@@ -228,7 +238,8 @@ def __init__(
             self.compression = "zip"
         elif _is_bz2file(fileobj):
             self.compression = "bzip2"
-
+        elif _is_lzmafile(fileobj):
+            self.compression = "lzma"
         if (
             self.compression is not None
             and decompress_in_memory
@@ -557,6 +568,19 @@ def _try_read_compressed(self, obj_or_name, magic, mode, ext=""):
             bzip2_mode = "w" if is_ostream else "r"
             self._file = bz2.BZ2File(obj_or_name, mode=bzip2_mode)
             self.compression = "bzip2"
+        elif (is_ostream and ext == ".xz") or magic.startswith(LZMA_MAGIC):
+            # Handle lzma files
+            if mode in ["update", "append"]:
+                raise OSError(
+                    "update and append modes are not supported with lzma files"
+                )
+            if not HAS_LZMA:
+                raise ModuleNotFoundError(
+                    "This Python installation does not provide the lzma module."
+                )
+            lzma_mode = "w" if is_ostream else "r"
+            self._file = lzma.LZMAFile(obj_or_name, mode=lzma_mode)
+            self.compression = "lzma"
         return self.compression is not None
 
     def _open_fileobj(self, fileobj, mode, overwrite):
@@ -581,7 +605,7 @@ def _open_fileobj(self, fileobj, mode, overwrite):
             # means that the current file position is at the end of the file.
             if mode in ["ostream", "append"]:
                 self._file.seek(0)
-            magic = self._file.read(4)
+            magic = self._file.read(6)
             # No matter whether the underlying file was opened with 'ab' or
             # 'ab+', we need to return to the beginning of the file in order
             # to properly process the FITS header (and handle the possibility
@@ -641,7 +665,7 @@ def _open_filename(self, filename, mode, overwrite):
 
         if os.path.exists(self.name):
             with open(self.name, "rb") as f:
-                magic = f.read(4)
+                magic = f.read(6)
         else:
             magic = b""
 
@@ -654,7 +678,10 @@ def _open_filename(self, filename, mode, overwrite):
         # Make certain we're back at the beginning of the file
         # BZ2File does not support seek when the file is open for writing, but
         # when opening a file for write, bz2.BZ2File always truncates anyway.
-        if not (_is_bz2file(self._file) and mode == "ostream"):
+        if not (
+            (_is_bz2file(self._file) or (_is_lzmafile(self._file)))
+            and mode == "ostream"
+        ):
             self._file.seek(0)
 
     @classproperty(lazy=True)
diff --git a/astropy/io/fits/hdu/base.py b/astropy/io/fits/hdu/base.py
--- a/astropy/io/fits/hdu/base.py
+++ b/astropy/io/fits/hdu/base.py
@@ -395,10 +395,10 @@ def writeto(self, name, output_verify="exception", overwrite=False, checksum=Fal
 
         Notes
         -----
-        gzip, zip and bzip2 compression algorithms are natively supported.
+        gzip, zip, bzip2 and lzma compression algorithms are natively supported.
         Compression mode is determined from the filename extension
-        ('.gz', '.zip' or '.bz2' respectively).  It is also possible to pass a
-        compressed file object, e.g. `gzip.GzipFile`.
+        ('.gz', '.zip', '.bz2' or '.xz' respectively).  It is also possible to
+        pass a compressed file object, e.g. `gzip.GzipFile`.
         """
         from .hdulist import HDUList
 
diff --git a/astropy/io/fits/hdu/hdulist.py b/astropy/io/fits/hdu/hdulist.py
--- a/astropy/io/fits/hdu/hdulist.py
+++ b/astropy/io/fits/hdu/hdulist.py
@@ -27,7 +27,7 @@
 from astropy.utils.compat.numpycompat import NUMPY_LT_2_0
 
 # NOTE: Python can be built without bz2.
-from astropy.utils.compat.optional_deps import HAS_BZ2
+from astropy.utils.compat.optional_deps import HAS_BZ2, HAS_LZMA
 from astropy.utils.exceptions import AstropyUserWarning
 
 from .base import ExtensionHDU, _BaseHDU, _NonstandardHDU, _ValidHDU
@@ -39,6 +39,9 @@
 if HAS_BZ2:
     import bz2
 
+if HAS_LZMA:
+    import lzma
+
 __all__ = ["HDUList", "fitsopen"]
 
 # FITS file signature as per RFC 4047
@@ -1002,10 +1005,10 @@ def writeto(
 
         Notes
         -----
-        gzip, zip and bzip2 compression algorithms are natively supported.
+        gzip, zip, bzip2 and lzma compression algorithms are natively supported.
         Compression mode is determined from the filename extension
-        ('.gz', '.zip' or '.bz2' respectively).  It is also possible to pass a
-        compressed file object, e.g. `gzip.GzipFile`.
+        ('.gz', '.zip', '.bz2' or '.xz' respectively).  It is also possible to
+        pass a compressed file object, e.g. `gzip.GzipFile`.
         """
         if len(self) == 0:
             warnings.warn("There is nothing to write.", AstropyUserWarning)
@@ -1468,6 +1471,12 @@ def _flush_resize(self):
                         "This Python installation does not provide the bz2 module."
                     )
                 new_file = bz2.BZ2File(name, mode="w")
+            elif self._file.compression == "lzma":
+                if not HAS_LZMA:
+                    raise ModuleNotFoundError(
+                        "This Python installation does not provide the lzma module."
+                    )
+                new_file = lzma.LZMAFile(name, mode="w")
             else:
                 new_file = name
 