diff --git a/astropy/visualization/interval.py b/astropy/visualization/interval.py
--- a/astropy/visualization/interval.py
+++ b/astropy/visualization/interval.py
@@ -9,6 +9,8 @@
 
 import numpy as np
 
+from astropy.utils.masked import get_data_and_mask
+
 from .transform import BaseTransform
 
 __all__ = [
@@ -46,6 +48,31 @@ def get_limits(self, values):
         """
         raise NotImplementedError("Needs to be implemented in a subclass.")
 
+    @staticmethod
+    def _process_values(values):
+        """
+        Process the input values.
+
+        This function filters out masked and/or invalid values (inf,
+        nan) and returns a flattened 1D array.
+
+        Parameters
+        ----------
+        values : array-like
+            The input values.
+
+        Returns
+        -------
+        result : 1D ndarray
+            The processed values.
+        """
+        data, mask = get_data_and_mask(np.asanyarray(values))
+        ok = np.isfinite(data)
+        if mask is not None:
+            ok &= ~mask
+
+        return data[ok]
+
     def __call__(self, values, clip=True, out=None):
         """
         Transform values using this interval.
@@ -123,12 +150,7 @@ def get_limits(self, values):
         if self.vmin is not None and self.vmax is not None:
             return self.vmin, self.vmax
 
-        # Make sure values is a Numpy array
-        values = np.asarray(values).ravel()
-
-        # Filter out invalid values (inf, nan)
-        values = values[np.isfinite(values)]
-
+        values = self._process_values(values)
         vmin = np.min(values) if self.vmin is None else self.vmin
         vmax = np.max(values) if self.vmax is None else self.vmax
 
@@ -141,11 +163,7 @@ class MinMaxInterval(BaseInterval):
     """
 
     def get_limits(self, values):
-        # Make sure values is a Numpy array
-        values = np.asarray(values).ravel()
-
-        # Filter out invalid values (inf, nan)
-        values = values[np.isfinite(values)]
+        values = self._process_values(values)
 
         return np.min(values), np.max(values)
 
@@ -179,17 +197,13 @@ def __init__(self, lower_percentile=None, upper_percentile=None, n_samples=None)
         self.n_samples = n_samples
 
     def get_limits(self, values):
-        # Make sure values is a Numpy array
-        values = np.asarray(values).ravel()
+        values = self._process_values(values)
 
         # If needed, limit the number of samples. We sample with replacement
         # since this is much faster.
         if self.n_samples is not None and values.size > self.n_samples:
             values = np.random.choice(values, self.n_samples)
 
-        # Filter out invalid values (inf, nan)
-        values = values[np.isfinite(values)]
-
         # Determine values at percentiles
         vmin, vmax = np.percentile(
             values, (self.lower_percentile, self.upper_percentile)
@@ -274,9 +288,9 @@ def __init__(
         self.max_iterations = max_iterations
 
     def get_limits(self, values):
+        values = self._process_values(values)
+
         # Sample the image
-        values = np.asarray(values)
-        values = values[np.isfinite(values)]
         stride = int(max(1.0, values.size / self.n_samples))
         samples = values[::stride][: self.n_samples]
         samples.sort()