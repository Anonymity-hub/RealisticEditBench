diff --git a/django/template/base.py b/django/template/base.py
--- a/django/template/base.py
+++ b/django/template/base.py
@@ -53,6 +53,7 @@
 import inspect
 import logging
 import re
+import warnings
 from enum import Enum
 
 from django.template.context import BaseContext
@@ -88,11 +89,6 @@
 # than instantiating SimpleLazyObject with _lazy_re_compile().
 tag_re = re.compile(r"({%.*?%}|{{.*?}}|{#.*?#})")
 
-combined_partial_re = re.compile(
-    r"{%\s*partialdef\s+(?P<name>[\w-]+)(?:\s+inline)?\s*%}"
-    r"|{%\s*endpartialdef(?:\s+[\w-]+)?\s*%}"
-)
-
 logger = logging.getLogger("django.template")
 
 
@@ -300,36 +296,40 @@ class PartialTemplate:
     Wraps nodelist as a partial, in order to be able to bind context.
     """
 
-    def __init__(self, nodelist, origin, name):
+    def __init__(self, nodelist, origin, name, source_start=None, source_end=None):
         self.nodelist = nodelist
         self.origin = origin
         self.name = name
+        # If available (debug mode), the absolute character offsets in the
+        # template.source correspond to the full partial region.
+        self._source_start = source_start
+        self._source_end = source_end
 
     def get_exception_info(self, exception, token):
         template = self.origin.loader.get_template(self.origin.template_name)
         return template.get_exception_info(exception, token)
 
-    def find_partial_source(self, full_source, partial_name):
-        start_match = None
-        nesting = 0
-
-        for match in combined_partial_re.finditer(full_source):
-            if name := match["name"]:  # Opening tag.
-                if start_match is None and name == partial_name:
-                    start_match = match
-                if start_match is not None:
-                    nesting += 1
-            elif start_match is not None:
-                nesting -= 1
-                if nesting == 0:
-                    return full_source[start_match.start() : match.end()]
+    def find_partial_source(self, full_source):
+        if (
+            self._source_start is not None
+            and self._source_end is not None
+            and 0 <= self._source_start <= self._source_end <= len(full_source)
+        ):
+            return full_source[self._source_start : self._source_end]
 
         return ""
 
     @property
     def source(self):
         template = self.origin.loader.get_template(self.origin.template_name)
-        return self.find_partial_source(template.source, self.name)
+        if not template.engine.debug:
+            warnings.warn(
+                "PartialTemplate.source is only available when template "
+                "debugging is enabled.",
+                RuntimeWarning,
+                stacklevel=2,
+            )
+        return self.find_partial_source(template.source)
 
     def _render(self, context):
         return self.nodelist.render(context)
diff --git a/django/template/defaulttags.py b/django/template/defaulttags.py
--- a/django/template/defaulttags.py
+++ b/django/template/defaulttags.py
@@ -1235,19 +1235,32 @@ def partialdef_func(parser, token):
 
     # Parse the content until the end tag.
     valid_endpartials = ("endpartialdef", f"endpartialdef {partial_name}")
+
+    pos_open = getattr(token, "position", None)
+    source_start = pos_open[0] if isinstance(pos_open, tuple) else None
+
     nodelist = parser.parse(valid_endpartials)
     endpartial = parser.next_token()
     if endpartial.contents not in valid_endpartials:
         parser.invalid_block_tag(endpartial, "endpartialdef", valid_endpartials)
 
+    pos_close = getattr(endpartial, "position", None)
+    source_end = pos_close[1] if isinstance(pos_close, tuple) else None
+
     # Store the partial nodelist in the parser.extra_data attribute.
     partials = parser.extra_data.setdefault("partials", {})
     if partial_name in partials:
         raise TemplateSyntaxError(
             f"Partial '{partial_name}' is already defined in the "
             f"'{parser.origin.name}' template."
         )
-    partials[partial_name] = PartialTemplate(nodelist, parser.origin, partial_name)
+    partials[partial_name] = PartialTemplate(
+        nodelist,
+        parser.origin,
+        partial_name,
+        source_start=source_start,
+        source_end=source_end,
+    )
 
     return PartialDefNode(partial_name, inline, nodelist)
 