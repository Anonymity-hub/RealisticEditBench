diff --git a/xarray/backends/zarr.py b/xarray/backends/zarr.py
--- a/xarray/backends/zarr.py
+++ b/xarray/backends/zarr.py
@@ -602,9 +602,11 @@ class ZarrStore(AbstractWritableDataStore):
 
     __slots__ = (
         "_append_dim",
+        "_cache_members",
         "_close_store_on_close",
         "_consolidate_on_close",
         "_group",
+        "_members",
         "_mode",
         "_read_only",
         "_safe_chunks",
@@ -729,6 +731,7 @@ def __init__(
         write_empty: bool | None = None,
         close_store_on_close: bool = False,
         use_zarr_fill_value_as_mask=None,
+        cache_members: bool = True,
     ):
         self.zarr_group = zarr_group
         self._read_only = self.zarr_group.read_only
@@ -742,6 +745,20 @@ def __init__(
         self._write_empty = write_empty
         self._close_store_on_close = close_store_on_close
         self._use_zarr_fill_value_as_mask = use_zarr_fill_value_as_mask
+        self._cache_members: bool = cache_members
+        self._members: dict[str, ZarrArray | ZarrGroup] = {}
+
+        if self._cache_members:
+            # initialize the cache
+            # this cache is created here and never updated.
+            # If the `ZarrStore` instance creates a new zarr array, or if an external process
+            # removes an existing zarr array, then the cache will be invalid.
+            # We use this cache only to record any pre-existing arrays when the group was opened
+            # create a new ZarrStore instance if you want to
+            # capture the current state of the zarr group, or create a ZarrStore with
+            # `cache_members` set to `False` to disable this cache and instead fetch members
+            # on demand.
+            self._members = self._fetch_members()
 
     @property
     def ds(self):
