diff --git a/astropy/utils/decorators.py b/astropy/utils/decorators.py
--- a/astropy/utils/decorators.py
+++ b/astropy/utils/decorators.py
@@ -621,6 +621,41 @@ def wrapper(*args, **kwargs):
     return decorator
 
 
+def future_keyword_only(names: list[str], *, since=list[str]) -> FunctionType:
+    """Decorator to mark one or more function parameter(s) as future keyword-only.
+
+    Parameters
+    ----------
+    names: list[str]
+        names of parameters to be marked as future keyword-only
+    since: list[str]
+        versions in which each parameter was marked
+
+    Examples
+    --------
+    >>> @future_keyword_only(['spam', 'eggs'], since=['7.1', '7.1'])
+    ... def bacon(spam, eggs):
+    ...     ...
+    """
+
+    def decorate(raw_function):
+        # validate the conditions in which the decorator is used
+        # this adds a small overhead on startup time but not on function call
+
+        future_kwo_names = names
+        if len(future_kwo_names) != len(since):
+            raise ValueError(
+                "Expected names and since values with "
+                "identical length. "
+                f"Got {len(names)=} and {len(since)=}"
+            )
+        params = signature(raw_function).parameters
+        params_names: list[str] = list(params)
+        future_kwo_to_since = dict(zip(future_kwo_names, since))
+        ...
+    return decorate
+
+
 # TODO: This can still be made to work for setters by implementing an
 # accompanying metaclass that supports it; we just don't need that right this
 # second
