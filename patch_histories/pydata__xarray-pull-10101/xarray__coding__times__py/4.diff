diff --git a/xarray/coding/times.py b/xarray/coding/times.py
--- a/xarray/coding/times.py
+++ b/xarray/coding/times.py
@@ -1494,24 +1494,84 @@
 
     def decode(self, variable: Variable, name: T_Name = None) -> Variable:
         units = variable.attrs.get("units", None)
-        if isinstance(units, str) and units in TIME_UNITS:
-            if self._emit_decode_timedelta_future_warning:
-                emit_user_level_warning(
-                    "In a future version of xarray decode_timedelta will "
-                    "default to False rather than None. To silence this "
-                    "warning, set decode_timedelta to True, False, or a "
-                    "'CFTimedeltaCoder' instance.",
-                    FutureWarning,
-                )
+        has_timedelta_units = isinstance(units, str) and units in TIME_UNITS
+        has_timedelta_dtype = has_timedelta64_encoding_dtype(variable.attrs)
+        is_dtype_decodable = has_timedelta_units and has_timedelta_dtype
+        is_units_decodable = has_timedelta_units
+        if (is_dtype_decodable and self.decode_via_dtype) or (
+            is_units_decodable and self.decode_via_units
+        ):
             dims, data, attrs, encoding = unpack_for_decoding(variable)
-
             units = pop_to(attrs, encoding, "units")
-            dtype = np.dtype(f"timedelta64[{self.time_unit}]")
-            transform = partial(
-                decode_cf_timedelta, units=units, time_unit=self.time_unit
-            )
+            if is_dtype_decodable and self.decode_via_dtype:
+                if any(
+                    k in encoding for k in _INVALID_LITERAL_TIMEDELTA64_ENCODING_KEYS
+                ):
+                    raise ValueError(
+                        f"Decoding timedelta64 values via dtype is not "
+                        f"supported when 'add_offset', or 'scale_factor' are "
+                        f"present in encoding. Check the encoding parameters "
+                        f"of variable {name!r}."
+                    )
+                dtype = pop_to(attrs, encoding, "dtype", name=name)
+                dtype = np.dtype(dtype)
+                resolution, _ = np.datetime_data(dtype)
+                resolution = cast(NPDatetimeUnitOptions, resolution)
+                if np.timedelta64(1, resolution) > np.timedelta64(1, "s"):
+                    time_unit = cast(PDDatetimeUnitOptions, "s")
+                    dtype = np.dtype("timedelta64[s]")
+                    message = (
+                        f"Following pandas, xarray only supports decoding to "
+                        f"timedelta64 values with a resolution of 's', 'ms', "
+                        f"'us', or 'ns'. Encoded values for variable {name!r} "
+                        f"have a resolution of {resolution!r}. Attempting to "
+                        f"decode to a resolution of 's'. Note, depending on "
+                        f"the encoded values, this may lead to an "
+                        f"OverflowError. Additionally, data will not be "
+                        f"identically round tripped; xarray will choose an "
+                        f"encoding dtype of 'timedelta64[s]' when re-encoding."
+                    )
+                    emit_user_level_warning(message)
+                elif np.timedelta64(1, resolution) < np.timedelta64(1, "ns"):
+                    time_unit = cast(PDDatetimeUnitOptions, "ns")
+                    dtype = np.dtype("timedelta64[ns]")
+                    message = (
+                        f"Following pandas, xarray only supports decoding to "
+                        f"timedelta64 values with a resolution of 's', 'ms', "
+                        f"'us', or 'ns'. Encoded values for variable {name!r} "
+                        f"have a resolution of {resolution!r}. Attempting to "
+                        f"decode to a resolution of 'ns'. Note, depending on "
+                        f"the encoded values, this may lead to loss of "
+                        f"precision. Additionally, data will not be "
+                        f"identically round tripped; xarray will choose an "
+                        f"encoding dtype of 'timedelta64[ns]' "
+                        f"when re-encoding."
+                    )
+                    emit_user_level_warning(message)
+                else:
+                    time_unit = cast(PDDatetimeUnitOptions, resolution)
+            elif self.decode_via_units:
+                if self._emit_decode_timedelta_future_warning:
+                    emit_user_level_warning(
+                        "In a future version, xarray will not decode "
+                        "timedelta values based on the presence of a "
+                        "timedelta-like units attribute by default. Instead "
+                        "it will rely on the presence of a timedelta64 dtype "
+                        "attribute, which is now xarray's default way of "
+                        "encoding timedelta64 values. To continue decoding "
+                        "timedeltas based on the presence of a timedelta-like "
+                        "units attribute, users will need to explicitly "
+                        "opt-in by passing True or "
+                        "CFTimedeltaCoder(decode_via_units=True) to "
+                        "decode_timedelta. To silence this warning, set "
+                        "decode_timedelta to True, False, or a "
+                        "'CFTimedeltaCoder' instance.",
+                        FutureWarning,
+                    )
+                dtype = np.dtype(f"timedelta64[{self.time_unit}]")
+                time_unit = self.time_unit
+            transform = partial(decode_cf_timedelta, units=units, time_unit=time_unit)
             data = lazy_elemwise_func(data, transform, dtype=dtype)
-
             return Variable(dims, data, attrs, encoding, fastpath=True)
         else:
             return variable
