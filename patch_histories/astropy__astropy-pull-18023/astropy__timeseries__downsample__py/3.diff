diff --git a/astropy/timeseries/downsample.py b/astropy/timeseries/downsample.py
--- a/astropy/timeseries/downsample.py
+++ b/astropy/timeseries/downsample.py
@@ -1,6 +1,7 @@
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 
 import warnings
+from itertools import pairwise
 
 import numpy as np
 
@@ -35,6 +36,16 @@
         out_mask = counts <= 0
     else:
         # Derive counts from indices
+        counts = np.diff(indices, append=len(data))
+        out_mask = None
+
+    result = np.add.reduceat(unmasked, indices) / np.maximum(counts, 1)
+    if out_mask is not None:
+        result[out_mask] = np.nan
+    if data_mask is not None:  # Had masked input.
+        result = data.__class__(result, mask=out_mask, copy=False)
+
+    return result
 
 
 def reduceat(array, indices, function):
@@ -43,20 +54,9 @@
     It will check if the input function has a reduceat and call that if it does.
     """
     if len(indices) == 0:
-        return np.array([])
     elif function is nanmean_reduceat:
-        return np.array(function(array, indices))
     elif hasattr(function, "reduceat"):
-        return np.array(function.reduceat(array, indices))
     else:
-        result = []
-        for i in range(len(indices) - 1):
-            if indices[i + 1] <= indices[i] + 1:
-                result.append(function(array[indices[i]]))
-            else:
-                result.append(function(array[indices[i] : indices[i + 1]]))
-        result.append(function(array[indices[-1] :]))
-        return np.array(result)
 
 
 def _to_relative_longdouble(time: Time, rel_base: Time) -> np.longdouble:
 
