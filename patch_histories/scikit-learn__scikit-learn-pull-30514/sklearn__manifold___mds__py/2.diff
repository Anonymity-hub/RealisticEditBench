diff --git a/sklearn/manifold/_mds.py b/sklearn/manifold/_mds.py
--- a/sklearn/manifold/_mds.py
+++ b/sklearn/manifold/_mds.py
@@ -70,11 +70,13 @@
         See :term:`Glossary <random_state>`.
 
     normalized_stress : bool, default=False
-        Whether use and return normed stress value (Stress-1) instead of raw
-        stress calculated by default. Only supported in non-metric MDS. The
-        caller must ensure that if `normalized_stress=True` then `metric=False`
+        Whether use and return normalized stress value (Stress-1) instead of raw
+        stress.
 
         .. versionadded:: 1.2
+
+        .. versionchanged:: 1.7
+           Normalized stress is now supported for metric MDS as well.
 
     Returns
     -------
@@ -84,7 +86,7 @@
     stress : float
         The final value of the stress (sum of squared distance of the
         disparities and the distances for all constrained points).
-        If `normalized_stress=True`, and `metric=False` returns Stress-1.
+        If `normalized_stress=True`, returns Stress-1.
         A value of 0 indicates "perfect" fit, 0.025 excellent, 0.05 good,
         0.1 fair, and 0.2 poor [1]_.
 
@@ -107,8 +109,8 @@
     n_samples = dissimilarities.shape[0]
     random_state = check_random_state(random_state)
 
-    sim_flat = ((1 - np.tri(n_samples)) * dissimilarities).ravel()
-    sim_flat_w = sim_flat[sim_flat != 0]
+    dissimilarities_flat = ((1 - np.tri(n_samples)) * dissimilarities).ravel()
+    dissimilarities_flat_w = dissimilarities_flat[dissimilarities_flat != 0]
     if init is None:
         # Randomly choose initial configuration
         X = random_state.uniform(size=n_samples * n_components)
@@ -121,9 +123,14 @@
                 "init matrix should be of shape (%d, %d)" % (n_samples, n_components)
             )
         X = init
+    distances = euclidean_distances(X)
+
+    # Out of bounds condition cannot happen because we are transforming
+    # the training set here, but does sometimes get triggered in
+    # practice due to machine precision issues. Hence "clip".
+    ir = IsotonicRegression(out_of_bounds="clip")
 
     old_stress = None
-    ir = IsotonicRegression()
     for it in range(max_iter):
         # Compute distance and monotonic regression
         dis = euclidean_distances(X)