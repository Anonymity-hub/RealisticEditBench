diff --git a/xarray/coding/cftime_offsets.py b/xarray/coding/cftime_offsets.py
--- a/xarray/coding/cftime_offsets.py
+++ b/xarray/coding/cftime_offsets.py
@@ -609,14 +609,19 @@ def rollback(self, date):
             return date - YearEnd(month=self.month)
 
 
-class Day(Tick):
-    _freq = "D"
+class Day(BaseCFTimeOffset):
+    """Day offset following definition in pandas/_libs/tslibs/offsets.pyx"""
 
-    def as_timedelta(self) -> timedelta:
-        return timedelta(days=self.n)
+    _freq = "D"
 
     def __apply__(self, other):
-        return other + self.as_timedelta()
+        if isinstance(other, Day):
+            return Day(self.n + other.n)
+        else:
+            return other + timedelta(days=self.n)
+
+    def onOffset(self, date) -> bool:
+        return True
 
 
 class Hour(Tick):
@@ -718,8 +723,8 @@ def _generate_anchored_offsets(
 
 
 # pandas defines these offsets as "Tick" objects, which for instance have
-# distinct behavior from monthly or longer frequencies in resample.
-CFTIME_TICKS = (Day, Hour, Minute, Second)
+# distinct behavior from daily or longer frequencies in resample.
+CFTIME_TICKS = (Hour, Minute, Second)
 
 
 def _generate_anchored_deprecated_frequencies(
@@ -801,16 +806,13 @@ def delta_to_tick(delta: timedelta | pd.Timedelta) -> Tick:
             "nanoseconds to 'CFTimeOffset' object"
         )
     if delta.microseconds == 0:
-        if delta.seconds == 0:
-            return Day(n=delta.days)
+        seconds = delta.days * 86400 + delta.seconds
+        if seconds % 3600 == 0:
+            return Hour(n=seconds // 3600)
+        elif seconds % 60 == 0:
+            return Minute(n=seconds // 60)
         else:
-            seconds = delta.days * 86400 + delta.seconds
-            if seconds % 3600 == 0:
-                return Hour(n=seconds // 3600)
-            elif seconds % 60 == 0:
-                return Minute(n=seconds // 60)
-            else:
-                return Second(n=seconds)
+            return Second(n=seconds)
     # Regardless of the days and seconds this will always be a Millisecond
     # or Microsecond object
     elif delta.microseconds % 1_000 == 0:
diff --git a/xarray/coding/cftimeindex.py b/xarray/coding/cftimeindex.py
--- a/xarray/coding/cftimeindex.py
+++ b/xarray/coding/cftimeindex.py
@@ -490,7 +490,7 @@ def shift(  # type: ignore[override]  # freq is typed Any, we are more precise
         >>> index.shift(1, "ME")
         CFTimeIndex([2000-02-29 00:00:00],
                     dtype='object', length=1, calendar='standard', freq=None)
-        >>> index.shift(1.5, "D")
+        >>> index.shift(1.5, "24h")
         CFTimeIndex([2000-02-01 12:00:00],
                     dtype='object', length=1, calendar='standard', freq=None)
         """
@@ -707,16 +707,22 @@ def freq(self):
 
     def _round_via_method(self, freq, method):
         """Round dates using a specified method."""
-        from xarray.coding.cftime_offsets import CFTIME_TICKS, to_offset
+        from xarray.coding.cftime_offsets import CFTIME_TICKS, Day, to_offset
 
         if not self._data.size:
             return CFTimeIndex(np.array(self))
 
         offset = to_offset(freq)
-        if not isinstance(offset, CFTIME_TICKS):
+        if isinstance(offset, Day):
+            # Following pandas, "In the 'round' context, Day unambiguously
+            # means 24h, not calendar-day"
+            offset_as_timedelta = timedelta(days=offset.n)
+        elif isinstance(offset, CFTIME_TICKS):
+            offset_as_timedelta = offset.as_timedelta()
+        else:
             raise ValueError(f"{offset} is a non-fixed frequency")
 
-        unit = _total_microseconds(offset.as_timedelta())
+        unit = _total_microseconds(offset_as_timedelta)
         values = self.asi8
         rounded = method(values, unit)
         return _cftimeindex_from_i8(rounded, self.date_type, self.name)
diff --git a/xarray/core/resample_cftime.py b/xarray/core/resample_cftime.py
--- a/xarray/core/resample_cftime.py
+++ b/xarray/core/resample_cftime.py
@@ -45,6 +45,7 @@
 import pandas as pd
 
 from xarray.coding.cftime_offsets import (
+    CFTIME_TICKS,
     BaseCFTimeOffset,
     MonthEnd,
     QuarterEnd,
@@ -56,6 +57,7 @@
 )
 from xarray.coding.cftimeindex import CFTimeIndex
 from xarray.core.types import SideOptions
+from xarray.core.utils import emit_user_level_warning
 
 if typing.TYPE_CHECKING:
     from xarray.core.types import CFTimeDatetime, ResampleCompatible
@@ -84,6 +86,22 @@ def __init__(
         self.freq = to_offset(freq)
         self.origin = origin
 
+        if not isinstance(self.freq, CFTIME_TICKS):
+            if offset is not None:
+                message = (
+                    "The 'offset' keyword does not take effect when "
+                    "resampling with a 'freq' that is not Tick-like (h, m, s, "
+                    "ms, us)"
+                )
+                emit_user_level_warning(message, category=RuntimeWarning)
+            if origin != "start_day":
+                message = (
+                    "The 'origin' keyword does not take effect when "
+                    "resampling with a 'freq' that is not Tick-like (h, m, s, "
+                    "ms, us)"
+                )
+                emit_user_level_warning(message, category=RuntimeWarning)
+
         if isinstance(self.freq, MonthEnd | QuarterEnd | YearEnd) or self.origin in [
             "end",
             "end_day",