diff --git a/django/db/models/aggregates.py b/django/db/models/aggregates.py
--- a/django/db/models/aggregates.py
+++ b/django/db/models/aggregates.py
@@ -166,6 +166,7 @@ class Count(Aggregate):
     output_field = IntegerField()
     allow_distinct = True
     empty_result_set_value = 0
+    allows_composite_expressions = True
 
     def __init__(self, expression, filter=None, **extra):
         if expression == "*":
diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py
--- a/django/db/models/expressions.py
+++ b/django/db/models/expressions.py
@@ -184,6 +184,8 @@ class BaseExpression:
     constraint_validation_compatible = True
     # Does the expression possibly return more than one row?
     set_returning = False
+    # Does the expression allow composite expressions?
+    allows_composite_expressions = False
 
     def __init__(self, output_field=None):
         if output_field is not None:
@@ -758,6 +760,8 @@ def resolve_expression(
         rhs = self.rhs.resolve_expression(
             query, allow_joins, reuse, summarize, for_save
         )
+        if isinstance(lhs, ColPairs) or isinstance(rhs, ColPairs):
+            raise ValueError("CompositePrimaryKey is not combinable.")
         if not isinstance(self, (DurationExpression, TemporalSubtraction)):
             try:
                 lhs_type = lhs.output_field.get_internal_type()
@@ -1075,6 +1079,12 @@ def resolve_expression(
             c.source_expressions[pos] = arg.resolve_expression(
                 query, allow_joins, reuse, summarize, for_save
             )
+        if not self.allows_composite_expressions and any(
+            isinstance(expr, ColPairs) for expr in c.get_source_expressions()
+        ):
+            raise ValueError(
+                f"{self.__class__.__name__} does not support composite primary keys."
+            )
         return c
 
     def as_sql(
@@ -1825,6 +1835,7 @@ class OrderBy(Expression):
     template = "%(expression)s %(ordering)s"
     conditional = False
     constraint_validation_compatible = False
+    allows_composite_expressions = True
 
     def __init__(self, expression, descending=False, nulls_first=None, nulls_last=None):
         if nulls_first and nulls_last:
diff --git a/django/db/models/fields/tuple_lookups.py b/django/db/models/fields/tuple_lookups.py
--- a/django/db/models/fields/tuple_lookups.py
+++ b/django/db/models/fields/tuple_lookups.py
@@ -17,6 +17,7 @@
 
 
 class Tuple(Func):
+    allows_composite_expressions = True
     function = ""
     output_field = Field()
 
@@ -28,6 +29,8 @@ def __iter__(self):
 
 
 class TupleLookupMixin:
+    allows_composite_expressions = True
+
     def get_prep_lookup(self):
         self.check_rhs_is_tuple_or_list()
         self.check_rhs_length_equals_lhs_length()
diff --git a/django/db/models/lookups.py b/django/db/models/lookups.py
--- a/django/db/models/lookups.py
+++ b/django/db/models/lookups.py
@@ -4,7 +4,7 @@
 
 from django.core.exceptions import EmptyResultSet, FullResultSet
 from django.db.backends.base.operations import BaseDatabaseOperations
-from django.db.models.expressions import Case, Expression, Func, Value, When
+from django.db.models.expressions import Case, ColPairs, Expression, Func, Value, When
 from django.db.models.fields import (
     BooleanField,
     CharField,
@@ -119,6 +119,10 @@ def process_rhs(self, compiler, connection):
             value = value.resolve_expression(compiler.query)
         if hasattr(value, "as_sql"):
             sql, params = compiler.compile(value)
+            if isinstance(value, ColPairs):
+                raise ValueError(
+                    "CompositePrimaryKey cannot be used as a lookup value."
+                )
             # Ensure expression is wrapped in parentheses to respect operator
             # precedence but avoid double wrapping as it can be misinterpreted
             # on some backends (e.g. subqueries on SQLite).