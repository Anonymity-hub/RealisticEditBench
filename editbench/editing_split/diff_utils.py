import difflib
import re
import subprocess
from argparse import ArgumentParser
from pathlib import Path
from typing import Union


from editbench.editing_split.constants import EDITING_SPLIT_DIR


import tempfile
import os
import logging


logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")
logger = logging.getLogger(__name__)

class PatchApplyError(Exception):
    pass


def trim_diff_hunks(diff_content: str, context_lines: int = 3) -> str:
    """
    Trims each hunk in a diff to keep only 3 lines of irrelevant context
    before and after the modified content.
    :param diff_content: Original diff content as a string.
    :param context_lines: Number of context lines to keep (default: 3).
    :return: Trimmed diff content.
    """
    # Regex to match diff hunks (starts with @@, ends at next diff --git or EOF)
    hunk_pattern = re.compile(
        r'(diff --git .*?\n.*?\n)(@@ -(\d+),(\d+) \+(\d+),(\d+) @@)(.*?)(?=diff --git|$)',
        re.DOTALL | re.MULTILINE
    )

    trimmed_diff = []
    for match in hunk_pattern.finditer(diff_content):
        file_header = match.group(1)  # diff --git lines and --- +++ lines
        hunk_header = match.group(2)  # @@ -x,y +x,y @@
        hunk_body = match.group(6).strip()  # Content inside the hunk

        # Split hunk into lines (remove empty lines)
        lines = [line for line in hunk_body.split('\n') if line.strip() != '']

        # Locate modified lines (starting with - or +)
        modified_indices = [i for i, line in enumerate(lines) if line.startswith(('-', '+'))]
        if not modified_indices:
            trimmed_diff.append(file_header + hunk_header + '\n' + hunk_body + '\n')
            continue

        # Determine context range to keep (context_lines before/after modifications)
        start = max(0, modified_indices[0] - context_lines)
        end = min(len(lines), modified_indices[-1] + context_lines + 1)  # +1 to include end index

        # Extract trimmed lines and update hunk line counts
        trimmed_lines = lines[start:end]
        original_lines = len([line for line in trimmed_lines if not line.startswith('+')])
        modified_lines = len([line for line in trimmed_lines if not line.startswith('-')])

        # Regenerate hunk header with updated line numbers
        new_hunk_header = re.sub(
            r'@@ -\d+,\d+ \+\d+,\d+ @@',
            f'@@ -{match.group(3)},{original_lines} +{match.group(4)},{modified_lines} @@',
            hunk_header
        )

        # Assemble the trimmed hunk
        trimmed_hunk = (
                file_header
                + new_hunk_header + '\n'
                + '\n'.join(trimmed_lines) + '\n'
        )
        trimmed_diff.append(trimmed_hunk)

    return ''.join(trimmed_diff)


def generate_diff_with_file(old_file: Union[Path, str], new_file: Union[Path, str], filename: str, save_path=None) -> str:
    """
    Generate a git-style diff string between two file versions

    :param old_file: Path to the old version of the file
    :param new_file: Path to the new version of the file
    :param filename: Target filename to display in diff headers (with a/ and b/ prefixes)
    :param save_path: Location to save
    :return: Git-style formatted diff string
    """
    # Read file contents (split by lines while preserving line endings)
    old_content = Path(old_file).read_text()
    new_content = Path(new_file).read_text()
    diff_content = generate_diff(old_content, new_content, filename)
    if save_path:
        save_path = Path(save_path)
        save_path.write_text(diff_content)
    return diff_content


def generate_diff(old_content: str, new_content: str, filename: str) -> str:
    # Read file contents (split by lines while preserving line endings)
    old_lines = old_content.splitlines(keepends=True)
    new_lines = new_content.splitlines(keepends=True)

    # Generate base unified diff (difflib uses -/+ for old/new by default)
    raw_diff = list(difflib.unified_diff(
        old_lines, new_lines,
        fromfile=f"a/{filename}",  # Corresponds to git's a/ prefix
        tofile=f"b/{filename}",  # Corresponds to git's b/ prefix
        lineterm="\n"  # Prevent difflib from adding extra newlines
    ))

    # Add git-specific diff header (not generated by difflib)
    git_header = f"diff --git a/{filename} b/{filename}\n"
    return git_header + "".join(raw_diff)


def apply_diff(original_content: str, diff_content: str, fuzz: int = 1, strip: int = 1) -> str:
    """
    Apply a diff patch to original content using the system 'patch' command, supporting fuzzy matching.

    Args:
        original_content: Text of the original file
        diff_content: Patch content in unified diff format
        fuzz: Maximum allowed line offset for fuzzy matching (default: 5)
        strip: Number of path prefixes to remove (default: 1, like -p1)

    Returns:
        (New content, Success status, Logs)
    """
    logs = []
    # try:
    # Create temporary directory to avoid modifying real files
    with tempfile.TemporaryDirectory() as tmpdir:
        # Write original content to a temporary file
        original_path = os.path.join(tmpdir, "original.txt")
        with open(original_path, "w", encoding="utf-8") as f:
            f.write(original_content)

        # Write diff content to a temporary patch file
        patch_path = os.path.join(tmpdir, "patch.diff")
        with open(patch_path, "w", encoding="utf-8") as f:
            f.write(diff_content)

        # Run 'patch' command with parameters: --batch (non-interactive), --fuzz, -p
        cmd = [
            "patch",
            # "--forward",
            "--batch",  # Non-interactive mode (auto-accept defaults)
            f"--fuzz={fuzz}",  # Allow up to 'fuzz' line offset
            f"-p{strip}",  # Remove 'strip' path prefixes
            "-i", patch_path,  # Input patch file
            original_path  # Target file to patch
        ]

        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            check=False  # Don't raise exception; handle errors manually
        )

        # Collect command output for logs
        logs = [
            "Command executed: " + " ".join(cmd),
            "Stdout: " + result.stdout,
            "Stderr: " + result.stderr
        ]

        # Check if patch succeeded (exit code 0 or 1 for warnings)
        success = result.returncode == 0

        if not success or 'Reversed (or previously applied) patch detected!' in result.stdout:
            error_msg = (
                "Apply failedï¼\n"
                f"return code: {result.returncode}\n"
                f"command: {' '.join(cmd)}\n"
                f"stdout: {result.stdout.strip()}\n"
                f"stderror: {result.stderr.strip()}"
            )
            raise PatchApplyError(error_msg)

        # Read the patched content
        with open(original_path, "r", encoding="utf-8") as f:
            new_content = f.read()

        # return new_content, success, logs
        return new_content

    # except Exception as e:
    #     return "", False, [f"Error during patching: {str(e)}"]


def apply_diff_with_file(original_file: Union[Path, str], diff_path: Union[Path, str], fuzz: int = 1,
                         strip: int = 1, save_path: str = None) -> str:
    # Read file contents (split by lines while preserving line endings)
    original_content = Path(original_file).read_text()
    diff_content = Path(diff_path).read_text()

    result = apply_diff(original_content, diff_content, fuzz, strip)

    if save_path:
        save_path = Path(save_path)
        save_path.write_text(result)

    return result


def diff_minus(filename: str, original_file: Union[Path, str], sub_diff: Union[Path, str],
               original_diff: Union[Path, str],
               save_path: Union[Path, str] = None):
    mid_file_content = apply_diff_with_file(original_file, sub_diff)

    final_file_content = apply_diff_with_file(original_file, original_diff)

    diff_content = generate_diff(mid_file_content, final_file_content, filename)

    if save_path:
        save_path = Path(save_path)
        save_path.write_text(diff_content)

    return diff_content


def apply_patch_batch(original_file: Union[Path, str], diff_path_list: Union[list[Path], list[str]], fuzz: int = 1,
                      strip: int = 0, save_path: str = None):
    origin_content = Path(original_file).read_text()

    for diff_path in diff_path_list:
        diff_content = Path(diff_path).read_text()
        origin_content = apply_diff(origin_content, diff_content, fuzz, strip)

    if save_path:
        Path(save_path).write_text(origin_content)

    return origin_content


def quick_generate_sub_diff(instance_id: str, step_index: str):
    """
    Quickly generate a sub diff.
    :param instance_id:
    :param step_index:
    :return:
    """
    src_path = EDITING_SPLIT_DIR / instance_id

    if not src_path.exists():
        raise FileNotFoundError(f"Instance root directory does not exist: {src_path}")

    try:
        step = int(step_index)
    except ValueError as e:
        raise ValueError(f"step_index must be an integer, current value: {step_index}") from e

    for sub_dir in src_path.iterdir():
        if not sub_dir.is_dir():
            continue
        diff1_path = (sub_dir / "1.diff") if step_index == "2" and (sub_dir / "1.diff").exists() else  (sub_dir / f"{int(step_index) - 1}.1.diff")
        if not diff1_path.exists():
            logger.warning(f"Previous diff file does not exist: {diff1_path}")
            continue
        text = diff1_path.read_text()
        match = re.search(r'diff --git a/(\S+) b/\S+', text)
        filename = match.group(1) if match else ""
        file1 = sub_dir / "original.py" if step_index == "2" else sub_dir / f"{int(step_index) - 2}.py"
        if not file1.exists():
            f_index = file1.name[:-3]
            ge_file = sub_dir / "original.py" if f_index == "1" else sub_dir / f"{int(f_index) - 1}.py"
            ge_diff = sub_dir / f"{int(f_index)}.diff"
            save_path = sub_dir / f"{int(f_index)}.py"
            apply_diff_with_file(ge_file, ge_diff, save_path=save_path)
        diff2_path = sub_dir / "whole-1.diff"  if step_index == "2" else sub_dir / f"{int(step_index) - 1}.diff"
        res_diff_path = sub_dir / f"{step_index}.diff"
        diff_minus(filename, file1, diff1_path, diff2_path, res_diff_path)
        if step_index != "2":
            replace_file(diff2_path, diff1_path)

        logger.info(f"Sub directory {sub_dir.name} processed, target diff: {res_diff_path}")


def quick_split_diff(instance_id: str, start_index: int):
    src_path = EDITING_SPLIT_DIR / instance_id
    if not src_path.exists():
        raise FileNotFoundError(f"Instance root directory does not exist: {src_path}")
    ground_truth = []
    file_context = {}
    for sub_dir in src_path.iterdir():
        if not sub_dir.is_dir():
            continue
        batch_list = []
        for i in range(1, start_index + 1):
            path_ = sub_dir / f"{str(i)}.diff"
            if path_.exists():
                batch_list.append(path_)
        match = re.search(r'diff --git a/(\S+) b/\S+', (sub_dir/"whole-1.diff").read_text())
        filename = match.group(1) if match else ""
        before_content = apply_patch_batch(sub_dir/"original.py", batch_list)
        file_context[filename] = before_content
        after_content = (sub_dir/"final.py").read_text()

        diff_content = generate_diff(before_content, after_content, filename)
        if len(diff_content.strip().split("\n")) > 2:
            ground_truth.append(diff_content)
    return "\n".join(ground_truth), file_context


def replace_file(file_to_delete: str, source_file: str) -> None:
    """
    Delete file_to_delete, then rename source_file to the name of file_to_delete
    :param file_to_delete: The file to be deleted (target file name)
    :param source_file: The file to be renamed (source file name)
    """

    target = Path(file_to_delete)
    source = Path(source_file)

    if not source.exists():
        raise FileNotFoundError(f"Source file does not exist: {source}")
    if not source.is_file():
        raise IsADirectoryError(f"Source path is not a file: {source}")

    try:
        target.unlink(missing_ok=True)

        source.rename(target)
        print(f"{source} renamed to {target}")

    except PermissionError:
        raise PermissionError(f"No permission to operate file: {target} or {source} is occupied")
    except Exception as e:
        raise RuntimeError(f"Operation failed: {str(e)}")





if __name__ == "__main__":
    # Example:
    #   python -m editbench.editing_split.diff_utils gene --filename foo.py --file1 old.py --file2 new.py [--res out.diff]
    #   python -m editbench.editing_split.diff_utils apply --file base.txt --diff patch.diff [--res patched.txt] [--fuzz 1 --strip 1]
    #   python -m editbench.editing_split.diff_utils batch_apply --file base.txt --diffs 1.diff 2.diff [--res out.txt]
    #   python -m editbench.editing_split.diff_utils diff_minus --filename x.py --file orig.py --diff1 sub.diff --diff2 full.diff [--res result.diff]
    #   python -m editbench.editing_split.diff_utils quick_diff --instance_id astropy__astropy-pull-123 --step_index 2
    #   python -m editbench.editing_split.diff_utils trim --input in.diff [--output out.diff] [--context 3]
    parser = ArgumentParser(
        description="Diff utilities: generate git-style diff, apply patch, batch apply, diff_minus, quick_split, trim hunks.",
    )
    subparsers = parser.add_subparsers(dest="command", required=True, help="Subcommand to run")

    gene_parser = subparsers.add_parser("gene", help="Generate git-style diff between two files")
    gene_parser.add_argument("--filename", required=True, type=str, help="Filename for diff header (e.g. path/to/file.py)")
    gene_parser.add_argument("--file1", required=True, type=str, help="Path to old file")
    gene_parser.add_argument("--file2", required=True, type=str, help="Path to new file")
    gene_parser.add_argument("--res", type=str, default=None, help="Optional: save diff to this path")

    apply_parser = subparsers.add_parser("apply", help="Apply a diff/patch to a file")
    apply_parser.add_argument("--file", required=True, type=str, help="Path to file to patch")
    apply_parser.add_argument("--diff", required=True, type=str, help="Path to patch/diff file")
    apply_parser.add_argument("--fuzz", type=int, default=1, help="Patch fuzz (default: 1)")
    apply_parser.add_argument("--strip", type=int, default=1, help="Strip path components -p (default: 1)")
    apply_parser.add_argument("--res", type=str, default=None, help="Optional: save patched content to this path")

    apply_batch_parser = subparsers.add_parser("batch_apply", help="Apply multiple diffs in order to a file")
    apply_batch_parser.add_argument("--file", required=True, type=str, help="Path to base file")
    apply_batch_parser.add_argument("--diffs", nargs="+", required=True, type=str, help="Paths to diff files in order")
    apply_batch_parser.add_argument("--fuzz", type=int, default=1, help="Patch fuzz (default: 1)")
    apply_batch_parser.add_argument("--strip", type=int, default=0, help="Strip path components -p (default: 0)")
    apply_batch_parser.add_argument("--res", type=str, default=None, help="Optional: save result to this path")

    diff_minus_parser = subparsers.add_parser("diff_minus", help="Compute diff between two patch results (mid vs final)")
    diff_minus_parser.add_argument("--filename", required=True, type=str, help="Filename for output diff header")
    diff_minus_parser.add_argument("--file", required=True, type=str, help="Path to original file")
    diff_minus_parser.add_argument("--diff1", required=True, type=str, help="Path to first (sub) diff")
    diff_minus_parser.add_argument("--diff2", required=True, type=str, help="Path to second (full) diff")
    diff_minus_parser.add_argument("--res", type=str, default=None, help="Optional: save result diff to this path")

    quick_diff_parser = subparsers.add_parser("quick_diff", help="Generate sub-diffs for an instance under EDITING_SPLIT_DIR")
    quick_diff_parser.add_argument("--instance_id", required=True, type=str, help="Instance id (e.g. repo__repo-pull-123)")
    quick_diff_parser.add_argument("--step_index", required=True, type=str, help="Step index (e.g. 2)")

    trim_parser = subparsers.add_parser("trim", help="Trim diff hunks to limited context lines")
    trim_parser.add_argument("--input", required=True, type=str, help="Path to input diff file")
    trim_parser.add_argument("--output", type=str, default=None, help="Optional: output path; if omitted, print to stdout")
    trim_parser.add_argument("--context", type=int, default=3, help="Context lines to keep (default: 3)")

    args = parser.parse_args()

    if args.command == "gene":
        res = generate_diff_with_file(args.file1, args.file2, args.filename, args.res)
        if args.res:
            print(f"Saved diff to {args.res}")
        else:
            print(res[:2000] + ("..." if len(res) > 2000 else ""))
    elif args.command == "apply":
        res = apply_diff_with_file(args.file, args.diff, args.fuzz, args.strip, args.res)
        if args.res:
            print(f"Saved patched content to {args.res}")
        else:
            print(res[:2000] + ("..." if len(res) > 2000 else ""))
    elif args.command == "batch_apply":
        res = apply_patch_batch(args.file, args.diffs, args.fuzz, args.strip, args.res)
        if args.res:
            print(f"Saved result to {args.res}")
        else:
            print(res[:2000] + ("..." if len(res) > 2000 else ""))
    elif args.command == "diff_minus":
        res = diff_minus(args.filename, args.file, args.diff1, args.diff2, args.res)
        if args.res:
            print(f"Saved diff to {args.res}")
        else:
            print(res[:2000] + ("..." if len(res) > 2000 else ""))
    elif args.command == "quick_diff":
        quick_generate_sub_diff(args.instance_id, args.step_index)
        print(f"Done. Instance {args.instance_id} step_index={args.step_index}")
    elif args.command == "trim":
        content = Path(args.input).read_text()
        out = trim_diff_hunks(content, context_lines=args.context)
        if args.output:
            Path(args.output).write_text(out)
            print(f"Saved trimmed diff to {args.output}")
        else:
            print(out)
